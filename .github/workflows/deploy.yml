name: üöÄ Automated Deployment

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment Environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      strategy:
        description: 'Deployment Strategy'
        required: true
        default: 'rolling'
        type: choice
        options:
          - rolling
          - canary
          - blue-green

env:
  NODE_VERSION: '20.19'
  PNPM_VERSION: '8.15.0'
  IMAGE_NAME: ghcr.io/${{ github.repository }}/dese-ea-plan-v5
  # Kubeconfig secret selection based on environment
  # Note: KUBECONFIG_SECRET is set dynamically in each job step using if conditions
  # Production uses KUBECONFIG_PRODUCTION, staging/others use KUBECONFIG_STAGING

jobs:
  # ===================================
  # PRE-FLIGHT CHECKS
  # ===================================
  preflight:
    name: ‚úàÔ∏è Pre-flight Checks
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: üì• Checkout
        uses: actions/checkout@v4

      - name: ‚òÅÔ∏è Setup GCloud with GKE Auth Plugin
        uses: google-github-actions/setup-gcloud@v2
        with:
          install_components: 'gke-gcloud-auth-plugin,kubectl'
          project_id: ${{ secrets.GCP_PROJECT_ID || 'ea-plan-seo-project' }}
          # Note: Service Account authentication via secrets.GCP_SA_KEY
          # For better security, consider using Workload Identity Federation
          service_account_key: ${{ secrets.GCP_SA_KEY }}
          export_default_credentials: true

      - name: üèóÔ∏è Setup helm
        uses: azure/setup-helm@v3

      - name: üõ°Ô∏è Validate kubeconfig secret (Fail-Fast)
        run: |
          ENV="${{ github.event.inputs.environment }}"
          echo "üîç Validating kubeconfig secret for environment: $ENV"
          
          # Set KUBECONFIG_SECRET dynamically based on environment
          if [ "$ENV" = "production" ]; then
            KUBECONFIG_SECRET="${{ secrets.KUBECONFIG_PRODUCTION }}"
          else
            KUBECONFIG_SECRET="${{ secrets.KUBECONFIG_STAGING }}"
          fi
          
          # Export to GITHUB_ENV for use in subsequent steps
          echo "KUBECONFIG_SECRET=${KUBECONFIG_SECRET}" >> $GITHUB_ENV
          
          if [ -z "${KUBECONFIG_SECRET}" ] || [ "${KUBECONFIG_SECRET}" = "" ]; then
            echo "::error::‚ùå CRITICAL: Kubeconfig secret is missing or empty!"
            echo "::error::Environment: $ENV"
            echo "::error::"
            echo "::error::Required GitHub Actions secrets:"
            if [ "$ENV" = "production" ]; then
              echo "::error::  - KUBECONFIG_PRODUCTION (required for production)"
            else
              echo "::error::  - KUBECONFIG_STAGING (required for staging)"
            fi
            echo "::error::"
            echo "::error::To set secrets:"
            echo "::error::  1. Go to Repository Settings > Secrets and variables > Actions"
            echo "::error::  2. Click 'New repository secret'"
            echo "::error::  3. Add the required secret name and value"
            echo "::error::  4. Re-run this workflow"
            exit 1
          fi
          
          echo "‚úÖ Kubeconfig secret validated successfully for environment: $ENV"
          echo "   Secret length: ${#KUBECONFIG_SECRET} characters"

      - name: üîê Configure kubectl
        env:
          KUBECONFIG_SECRET: ${{ env.KUBECONFIG_SECRET }}
        uses: azure/k8s-set-context@v3
        with:
          method: kubeconfig
          kubeconfig: ${{ env.KUBECONFIG_SECRET }}

      - name: üè≠ Validate Production Environment Secrets (if production)
        if: github.event.inputs.environment == 'production'
        run: |
          ENV="${{ github.event.inputs.environment }}"
          echo "üîç Validating production environment secrets..."
          
          MISSING_SECRETS=()
          
          # Required secrets for production
          if [ -z "${{ secrets.JWT_SECRET }}" ]; then
            MISSING_SECRETS+=("JWT_SECRET")
          fi
          
          if [ -z "${{ secrets.COOKIE_KEY }}" ]; then
            MISSING_SECRETS+=("COOKIE_KEY")
          fi
          
          if [ -z "${{ secrets.GOOGLE_CLIENT_ID }}" ]; then
            MISSING_SECRETS+=("GOOGLE_CLIENT_ID")
          fi
          
          if [ -z "${{ secrets.GOOGLE_CLIENT_SECRET }}" ]; then
            MISSING_SECRETS+=("GOOGLE_CLIENT_SECRET")
          fi
          
          if [ -z "${{ secrets.GOOGLE_CALLBACK_URL }}" ]; then
            MISSING_SECRETS+=("GOOGLE_CALLBACK_URL")
          fi
          
          if [ -z "${{ secrets.DATABASE_URL }}" ]; then
            MISSING_SECRETS+=("DATABASE_URL")
          fi
          
          if [ -z "${{ secrets.REDIS_URL }}" ]; then
            MISSING_SECRETS+=("REDIS_URL")
          fi
          
          # Prometheus URL - either PROMETHEUS_URL or MCP_PROMETHEUS_BASE_URL
          if [ -z "${{ secrets.PROMETHEUS_URL }}" ] && [ -z "${{ secrets.MCP_PROMETHEUS_BASE_URL }}" ]; then
            MISSING_SECRETS+=("PROMETHEUS_URL or MCP_PROMETHEUS_BASE_URL")
          fi
          
          if [ ${#MISSING_SECRETS[@]} -gt 0 ]; then
            echo "::error::‚ùå CRITICAL: Missing required production secrets!"
            echo "::error::Environment: $ENV"
            echo "::error::"
            echo "::error::Missing secrets:"
            for secret in "${MISSING_SECRETS[@]}"; do
              echo "::error::  - $secret"
            done
            echo "::error::"
            echo "::error::To set secrets:"
            echo "::error::  1. Go to Repository Settings > Secrets and variables > Actions"
            echo "::error::  2. Click 'New repository secret'"
            echo "::error::  3. Add the required secret name and value"
            echo "::error::  4. Re-run this workflow"
            exit 1
          fi
          
          echo "‚úÖ All required production secrets validated successfully"
          echo "   Secrets checked: JWT_SECRET, COOKIE_KEY, GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, GOOGLE_CALLBACK_URL, DATABASE_URL, REDIS_URL, PROMETHEUS_URL/MCP_PROMETHEUS_BASE_URL"

      - name: ‚úÖ Check cluster connectivity
        run: kubectl cluster-info

      - name: üìä Check cluster resources
        run: |
          echo "Nodes:"
          kubectl get nodes
          echo -e "\nNamespaces:"
          kubectl get ns

      - name: üîç Check existing deployment
        id: check-deployment
        run: |
          DEPLOYMENT_EXISTS=$(kubectl get deployment dese-api-deployment -n default --no-headers 2>&1 || echo "NOT_FOUND")
          echo "exists=$DEPLOYMENT_EXISTS" >> $GITHUB_OUTPUT
        continue-on-error: true

  # ===================================
  # CANARY DEPLOYMENT
  # ===================================
  deploy-canary:
    name: üê¶ Canary Deployment
    runs-on: ubuntu-latest
    needs: [preflight]
    if: github.event.inputs.strategy == 'canary'
    timeout-minutes: 30

    permissions:
      contents: read
      packages: write
      id-token: write # For signing

    steps:
      - name: üì• Checkout
        uses: actions/checkout@v4

      - name: ‚òÅÔ∏è Setup GCloud with GKE Auth Plugin
        uses: google-github-actions/setup-gcloud@v2
        with:
          install_components: 'gke-gcloud-auth-plugin,kubectl'
          project_id: ${{ secrets.GCP_PROJECT_ID || 'ea-plan-seo-project' }}
          # Note: Service Account authentication via secrets.GCP_SA_KEY
          # For better security, consider using Workload Identity Federation
          service_account_key: ${{ secrets.GCP_SA_KEY }}
          export_default_credentials: true

      - name: üõ°Ô∏è Validate kubeconfig secret (Fail-Fast)
        run: |
          ENV="${{ github.event.inputs.environment }}"
          echo "üîç Validating kubeconfig secret for environment: $ENV"
          
          # Set KUBECONFIG_SECRET dynamically based on environment
          if [ "$ENV" = "production" ]; then
            KUBECONFIG_SECRET="${{ secrets.KUBECONFIG_PRODUCTION }}"
          else
            KUBECONFIG_SECRET="${{ secrets.KUBECONFIG_STAGING }}"
          fi
          
          # Export to GITHUB_ENV for use in subsequent steps
          echo "KUBECONFIG_SECRET=${KUBECONFIG_SECRET}" >> $GITHUB_ENV
          
          if [ -z "${KUBECONFIG_SECRET}" ] || [ "${KUBECONFIG_SECRET}" = "" ]; then
            echo "::error::‚ùå CRITICAL: Kubeconfig secret is missing or empty!"
            echo "::error::Environment: $ENV"
            echo "::error::"
            echo "::error::Required GitHub Actions secrets:"
            if [ "$ENV" = "production" ]; then
              echo "::error::  - KUBECONFIG_PRODUCTION (required for production)"
            else
              echo "::error::  - KUBECONFIG_STAGING (required for staging)"
            fi
            echo "::error::"
            echo "::error::To set secrets:"
            echo "::error::  1. Go to Repository Settings > Secrets and variables > Actions"
            echo "::error::  2. Click 'New repository secret'"
            echo "::error::  3. Add the required secret name and value"
            echo "::error::  4. Re-run this workflow"
            exit 1
          fi
          
          echo "‚úÖ Kubeconfig secret validated successfully for environment: $ENV"
          echo "   Secret length: ${#KUBECONFIG_SECRET} characters"

      - name: üîê Configure kubectl
        env:
          KUBECONFIG_SECRET: ${{ env.KUBECONFIG_SECRET }}
        uses: azure/k8s-set-context@v3
        with:
          method: kubeconfig
          kubeconfig: ${{ env.KUBECONFIG_SECRET }}

      - name: ‚úíÔ∏è Sign the container image
        uses: sigstore/cosign-installer@v3
      - run: |-
          cosign sign --yes "${{ env.IMAGE_NAME }}@${{ github.sha }}"
        env:
          COSIGN_EXPERIMENTAL: "true"

      - name: ‚úÖ Verify image signature
        run: |-
          cosign verify --key "https://dev.sigstore.dev/fulcio/dev-instance" "${{ env.IMAGE_NAME }}@${{ github.sha }}"

      - name: üê¶ Create canary deployment
        run: |
          kubectl apply -f - <<EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: dese-ea-plan-v5-canary
            namespace: dese-ea-plan-v5
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: dese-ea-plan-v5-canary
            template:
              metadata:
                labels:
                  app: dese-ea-plan-v5-canary
                  version: canary
              spec:
                containers:
                - name: dese-ea-plan-v5
                  image: ${{ env.IMAGE_NAME }}:${{ github.sha }}
                  ports:
                  - containerPort: 3000
          EOF

      - name: ‚úÖ Wait for canary
        run: |
          kubectl rollout status deployment/dese-ea-plan-v5-canary -n dese-ea-plan-v5 --timeout=5m

      - name: üß™ Test canary
        run: |
          CANARY_POD=$(kubectl get pod -n dese-ea-plan-v5 -l app=dese-ea-plan-v5-canary -o jsonpath='{.items[0].metadata.name}')
          kubectl exec -n dese-ea-plan-v5 $CANARY_POD -- curl -f http://localhost:3000/health
          echo "‚úÖ Canary health check passed"

      - name: üîç Monitor metrics (60s)
        run: |
          echo "Monitoring canary metrics for 60 seconds..."
          sleep 60
          kubectl top pod -n dese-ea-plan-v5 -l app=dese-ea-plan-v5-canary

      - name: ‚úÖ Promote canary
        run: |
          # Scale up canary to full deployment
          kubectl scale deployment dese-ea-plan-v5-canary -n dese-ea-plan-v5 --replicas=3
          kubectl label deployment dese-ea-plan-v5-canary -n dese-ea-plan-v5 app=dese-ea-plan-v5 --overwrite
          
          # Annotate rollout
          kubectl annotate deployment dese-ea-plan-v5-canary -n dese-ea-plan-v5 \
            deployment.kubernetes.io/revision="$(date +%s)" \
            deployment.kubernetes.io/revision-reason="Canary promoted"

      - name: üßπ Cleanup
        if: always()
        run: |
          # Keep only promoted deployment
          echo "Canary deployment completed"

  # ===================================
  # ROLLING DEPLOYMENT
  # ===================================
  deploy-rolling:
    name: üîÑ Rolling Deployment
    runs-on: ubuntu-latest
    needs: [preflight]
    if: github.event.inputs.strategy == 'rolling'
    timeout-minutes: 30

    permissions:
      contents: read
      packages: write
      id-token: write # For signing

    steps:
      - name: üì• Checkout
        uses: actions/checkout@v4

      - name: ‚òÅÔ∏è Setup GCloud with GKE Auth Plugin
        uses: google-github-actions/setup-gcloud@v2
        with:
          install_components: 'gke-gcloud-auth-plugin,kubectl'
          project_id: ${{ secrets.GCP_PROJECT_ID || 'ea-plan-seo-project' }}
          # Note: Service Account authentication via secrets.GCP_SA_KEY
          # For better security, consider using Workload Identity Federation
          service_account_key: ${{ secrets.GCP_SA_KEY }}
          export_default_credentials: true

      - name: üõ°Ô∏è Validate kubeconfig secret (Fail-Fast)
        run: |
          ENV="${{ github.event.inputs.environment }}"
          echo "üîç Validating kubeconfig secret for environment: $ENV"
          
          # Set KUBECONFIG_SECRET dynamically based on environment
          if [ "$ENV" = "production" ]; then
            KUBECONFIG_SECRET="${{ secrets.KUBECONFIG_PRODUCTION }}"
          else
            KUBECONFIG_SECRET="${{ secrets.KUBECONFIG_STAGING }}"
          fi
          
          # Export to GITHUB_ENV for use in subsequent steps
          echo "KUBECONFIG_SECRET=${KUBECONFIG_SECRET}" >> $GITHUB_ENV
          
          if [ -z "${KUBECONFIG_SECRET}" ] || [ "${KUBECONFIG_SECRET}" = "" ]; then
            echo "::error::‚ùå CRITICAL: Kubeconfig secret is missing or empty!"
            echo "::error::Environment: $ENV"
            echo "::error::"
            echo "::error::Required GitHub Actions secrets:"
            if [ "$ENV" = "production" ]; then
              echo "::error::  - KUBECONFIG_PRODUCTION (required for production)"
            else
              echo "::error::  - KUBECONFIG_STAGING (required for staging)"
            fi
            echo "::error::"
            echo "::error::To set secrets:"
            echo "::error::  1. Go to Repository Settings > Secrets and variables > Actions"
            echo "::error::  2. Click 'New repository secret'"
            echo "::error::  3. Add the required secret name and value"
            echo "::error::  4. Re-run this workflow"
            exit 1
          fi
          
          echo "‚úÖ Kubeconfig secret validated successfully for environment: $ENV"
          echo "   Secret length: ${#KUBECONFIG_SECRET} characters"

      - name: üîê Configure kubectl
        env:
          KUBECONFIG_SECRET: ${{ env.KUBECONFIG_SECRET }}
        uses: azure/k8s-set-context@v3
        with:
          method: kubeconfig
          kubeconfig: ${{ env.KUBECONFIG_SECRET }}

      - name: ‚úíÔ∏è Sign the container image
        uses: sigstore/cosign-installer@v3
      - run: |-
          cosign sign --yes "${{ env.IMAGE_NAME }}@${{ github.sha }}"
        env:
          COSIGN_EXPERIMENTAL: "true"

      - name: ‚úÖ Verify image signature
        run: |-
          cosign verify --key "https://dev.sigstore.dev/fulcio/dev-instance" "${{ env.IMAGE_NAME }}@${{ github.sha }}"

      - name: üîÑ Apply Backend API Deployment
        run: |
          echo "Applying backend API deployment from k8s/deployment-api.yaml..."
          
          # Update image tag in deployment file using sed (Linux/GitHub Actions compatible)
          # The deployment uses GCR image format: europe-west3-docker.pkg.dev/.../dese-api:v6.8.2
          # We'll update only the tag part (after the colon) to use the commit SHA
          sed -i "s|image:.*dese-api:.*|image: europe-west3-docker.pkg.dev/ea-plan-seo-project/dese-ea-plan-images/dese-api:${{ github.sha }}|g" k8s/deployment-api.yaml
          
          # Apply the deployment
          kubectl apply -f k8s/deployment-api.yaml
          
          echo "‚úÖ Backend API deployment applied successfully"
          echo "üì¶ Image: europe-west3-docker.pkg.dev/ea-plan-seo-project/dese-ea-plan-images/dese-api:${{ github.sha }}"

      - name: ‚úÖ Wait for rollout
        run: |
          kubectl rollout status deployment/dese-api-deployment -n default --timeout=10m

      - name: üß™ Comprehensive Health Check
        run: |
          # Get service endpoint for dese-api-service
          SERVICE_URL=$(kubectl get svc dese-api-service -n default -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
          USE_PORT_FORWARD=false
          
          if [ -z "$SERVICE_URL" ]; then
            echo "‚ö†Ô∏è Service does not have external IP, testing via port-forward..."
            USE_PORT_FORWARD=true
            kubectl port-forward -n default svc/dese-api-service 8080:3001 &
            PF_PID=$!
            sleep 5
            BASE_URL="http://localhost:8080"
          else
            BASE_URL="https://$SERVICE_URL"
          fi
          
          # Wait for service to be ready with retries
          MAX_RETRIES=10
          RETRY_COUNT=0
          SERVICE_READY=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if curl -sf "${BASE_URL}/health/live" > /dev/null 2>&1; then
              SERVICE_READY=true
              echo "‚úÖ Service is ready (attempt $((RETRY_COUNT + 1)))"
              break
            fi
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "‚è≥ Waiting for service to be ready (attempt $RETRY_COUNT/$MAX_RETRIES)..."
            sleep 10
          done
          
          if [ "$SERVICE_READY" = false ]; then
            echo "::error::‚ùå Service health check failed after $MAX_RETRIES attempts"
            if [ "$USE_PORT_FORWARD" = true ]; then
              kill $PF_PID 2>/dev/null || true
            fi
            exit 1
          fi
          
          # Run comprehensive health checks
          echo "üß™ Running comprehensive API health checks..."
          
          # 1. Health check
          echo -n "  ‚úì GET /health/live: "
          if curl -sf "${BASE_URL}/health/live" > /dev/null; then
            echo "‚úÖ PASS"
          else
            echo "‚ùå FAIL"
            EXIT_CODE=1
          fi
          
          # 2. API root
          echo -n "  ‚úì GET /api/v1: "
          if curl -sf "${BASE_URL}/api/v1" > /dev/null; then
            echo "‚úÖ PASS"
          else
            echo "‚ùå FAIL"
            EXIT_CODE=1
          fi
          
          # 3. Metrics endpoint
          echo -n "  ‚úì GET /metrics: "
          if curl -sf "${BASE_URL}/metrics" > /dev/null; then
            echo "‚úÖ PASS"
          else
            echo "‚ùå FAIL"
            EXIT_CODE=1
          fi
          
          # 4. GET /api/v1/auth/login (should return 405)
          echo -n "  ‚úì GET /api/v1/auth/login (405): "
          STATUS_CODE=$(curl -s -o /dev/null -w "%{http_code}" "${BASE_URL}/api/v1/auth/login")
          if [ "$STATUS_CODE" = "405" ]; then
            echo "‚úÖ PASS (got $STATUS_CODE)"
          else
            echo "‚ùå FAIL (got $STATUS_CODE, expected 405)"
            EXIT_CODE=1
          fi
          
          # Cleanup port-forward if used
          if [ "$USE_PORT_FORWARD" = true ]; then
            kill $PF_PID 2>/dev/null || true
          fi
          
          if [ "${EXIT_CODE:-0}" -eq 1 ]; then
            echo "::error::‚ùå One or more health checks failed"
            exit 1
          fi
          
          echo "‚úÖ All health checks passed successfully!"

  # ===================================
  # POST-DEPLOYMENT VALIDATION
  # ===================================
  validate-deployment:
    name: ‚úÖ Validate Deployment
    runs-on: ubuntu-latest
    needs: [deploy-canary, deploy-rolling]
    if: always()
    timeout-minutes: 15

    steps:
      - name: üì• Checkout
        uses: actions/checkout@v4

      - name: ‚òÅÔ∏è Setup GCloud with GKE Auth Plugin
        uses: google-github-actions/setup-gcloud@v2
        with:
          install_components: 'gke-gcloud-auth-plugin,kubectl'
          project_id: ${{ secrets.GCP_PROJECT_ID || 'ea-plan-seo-project' }}
          # Note: Service Account authentication via secrets.GCP_SA_KEY
          # For better security, consider using Workload Identity Federation
          service_account_key: ${{ secrets.GCP_SA_KEY }}
          export_default_credentials: true

      - name: üõ°Ô∏è Validate kubeconfig secret (Fail-Fast)
        run: |
          ENV="${{ github.event.inputs.environment }}"
          echo "üîç Validating kubeconfig secret for environment: $ENV"
          
          # Set KUBECONFIG_SECRET dynamically based on environment
          if [ "$ENV" = "production" ]; then
            KUBECONFIG_SECRET="${{ secrets.KUBECONFIG_PRODUCTION }}"
          else
            KUBECONFIG_SECRET="${{ secrets.KUBECONFIG_STAGING }}"
          fi
          
          # Export to GITHUB_ENV for use in subsequent steps
          echo "KUBECONFIG_SECRET=${KUBECONFIG_SECRET}" >> $GITHUB_ENV
          
          if [ -z "${KUBECONFIG_SECRET}" ] || [ "${KUBECONFIG_SECRET}" = "" ]; then
            echo "::error::‚ùå CRITICAL: Kubeconfig secret is missing or empty!"
            echo "::error::Environment: $ENV"
            echo "::error::"
            echo "::error::Required GitHub Actions secrets:"
            if [ "$ENV" = "production" ]; then
              echo "::error::  - KUBECONFIG_PRODUCTION (required for production)"
            else
              echo "::error::  - KUBECONFIG_STAGING (required for staging)"
            fi
            echo "::error::"
            echo "::error::To set secrets:"
            echo "::error::  1. Go to Repository Settings > Secrets and variables > Actions"
            echo "::error::  2. Click 'New repository secret'"
            echo "::error::  3. Add the required secret name and value"
            echo "::error::  4. Re-run this workflow"
            exit 1
          fi
          
          echo "‚úÖ Kubeconfig secret validated successfully for environment: $ENV"
          echo "   Secret length: ${#KUBECONFIG_SECRET} characters"

      - name: üîê Configure kubectl
        env:
          KUBECONFIG_SECRET: ${{ env.KUBECONFIG_SECRET }}
        uses: azure/k8s-set-context@v3
        with:
          method: kubeconfig
          kubeconfig: ${{ env.KUBECONFIG_SECRET }}

      - name: üìä Deployment status
        run: |
          echo "üìä Current Deployment Status:"
          kubectl get deployments -n default -l app=dese-api
          echo ""
          kubectl get pods -n default -l app=dese-api
          echo ""
          kubectl get svc -n default -l app=dese-api

      - name: üè• Health and Integrity Checks
        run: |
          PENDING_PODS=$(kubectl get pods -A --field-selector=status.phase=Pending -o name)
          if [ -n "$PENDING_PODS" ]; then
            echo "::error::‚ùå ERROR: Found pending pods in the cluster!"
            echo "$PENDING_PODS"
            exit 1
          fi
          echo "‚úÖ No pending pods found in the cluster."

          PODS=$(kubectl get pods -n default -l app=dese-api -o jsonpath='{.items[*].metadata.name}')
          
          if [ -z "$PODS" ]; then
            echo "::error::‚ùå ERROR: No pods found with label app=dese-api"
            exit 1
          fi
          
          HEALTH_CHECK_FAILED=0
          for POD in $PODS; do
            echo "Checking health of pod: $POD"
            if kubectl exec -n default $POD -c dese-api -- curl -sf http://localhost:3001/health/live > /dev/null 2>&1; then
              echo "‚úÖ $POD health check passed"
            else
              echo "::error::‚ùå Health check failed for pod: $POD"
              HEALTH_CHECK_FAILED=1
            fi
          done
          
          if [ $HEALTH_CHECK_FAILED -eq 1 ]; then
            echo "::error::‚ùå One or more pods failed health check"
            exit 1
          fi
          
          echo "‚úÖ All pods passed health checks"

      - name: üß™ API Endpoint Health Checks
        run: |
          # Get service endpoint
          SERVICE_URL=$(kubectl get svc dese-api-service -n default -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
          
          if [ -z "$SERVICE_URL" ]; then
            echo "‚ö†Ô∏è Service does not have external IP, using port-forward for health checks..."
            kubectl port-forward -n default svc/dese-api-service 8080:3001 &
            PF_PID=$!
            sleep 5
            BASE_URL="http://localhost:8080"
            USE_PORT_FORWARD=true
          else
            BASE_URL="https://$SERVICE_URL"
            USE_PORT_FORWARD=false
          fi
          
          echo "üß™ Running API endpoint health checks against: $BASE_URL"
          
          EXIT_CODE=0
          
          # Test 1: Health live endpoint
          echo -n "  ‚úì GET /health/live: "
          if curl -sf "${BASE_URL}/health/live" > /dev/null; then
            echo "‚úÖ PASS"
          else
            echo "‚ùå FAIL"
            EXIT_CODE=1
          fi
          
          # Test 2: API root
          echo -n "  ‚úì GET /api/v1: "
          if curl -sf "${BASE_URL}/api/v1" > /dev/null; then
            echo "‚úÖ PASS"
          else
            echo "‚ùå FAIL"
            EXIT_CODE=1
          fi
          
          # Test 3: Metrics endpoint
          echo -n "  ‚úì GET /metrics: "
          if curl -sf "${BASE_URL}/metrics" > /dev/null; then
            echo "‚úÖ PASS"
          else
            echo "‚ùå FAIL"
            EXIT_CODE=1
          fi
          
          # Test 4: GET /api/v1/auth/login (should return 405)
          echo -n "  ‚úì GET /api/v1/auth/login (405): "
          STATUS_CODE=$(curl -s -o /dev/null -w "%{http_code}" "${BASE_URL}/api/v1/auth/login")
          if [ "$STATUS_CODE" = "405" ]; then
            echo "‚úÖ PASS (got $STATUS_CODE)"
          else
            echo "‚ùå FAIL (got $STATUS_CODE, expected 405)"
            EXIT_CODE=1
          fi
          
          if [ "$USE_PORT_FORWARD" = true ]; then
            kill $PF_PID 2>/dev/null || true
          fi
          
          if [ $EXIT_CODE -eq 1 ]; then
            echo "::error::‚ùå One or more API endpoint health checks failed"
            exit 1
          fi
          
          echo "‚úÖ All API endpoint health checks passed successfully!"

      - name: üìà Performance metrics
        run: |
          kubectl top pods -n default -l app=dese-api --containers

      - name: üìã Pod logs (last 50 lines)
        if: failure()
        run: |
          kubectl logs -n default -l app=dese-api -c dese-api --tail=50

      - name: üìä Resource usage
        run: |
          kubectl top nodes
          kubectl top pods -n default -l app=dese-api

  # ===================================
  # ROLLBACK TRIGGER
  # ===================================
  rollback:
    name: ‚è™ Rollback
    runs-on: ubuntu-latest
    needs: [validate-deployment]
    if: failure() && github.event_name == 'workflow_dispatch'
    timeout-minutes: 10

    steps:
      - name: üì• Checkout
        uses: actions/checkout@v4

      - name: ‚òÅÔ∏è Setup GCloud with GKE Auth Plugin
        uses: google-github-actions/setup-gcloud@v2
        with:
          install_components: 'gke-gcloud-auth-plugin,kubectl'
          project_id: ${{ secrets.GCP_PROJECT_ID || 'ea-plan-seo-project' }}
          # Note: Service Account authentication via secrets.GCP_SA_KEY
          # For better security, consider using Workload Identity Federation
          service_account_key: ${{ secrets.GCP_SA_KEY }}
          export_default_credentials: true

      - name: üõ°Ô∏è Validate kubeconfig secret (Fail-Fast)
        run: |
          ENV="${{ github.event.inputs.environment }}"
          echo "üîç Validating kubeconfig secret for environment: $ENV"
          
          # Set KUBECONFIG_SECRET dynamically based on environment
          if [ "$ENV" = "production" ]; then
            KUBECONFIG_SECRET="${{ secrets.KUBECONFIG_PRODUCTION }}"
          else
            KUBECONFIG_SECRET="${{ secrets.KUBECONFIG_STAGING }}"
          fi
          
          # Export to GITHUB_ENV for use in subsequent steps
          echo "KUBECONFIG_SECRET=${KUBECONFIG_SECRET}" >> $GITHUB_ENV
          
          if [ -z "${KUBECONFIG_SECRET}" ] || [ "${KUBECONFIG_SECRET}" = "" ]; then
            echo "::error::‚ùå CRITICAL: Kubeconfig secret is missing or empty!"
            echo "::error::Environment: $ENV"
            echo "::error::"
            echo "::error::Required GitHub Actions secrets:"
            if [ "$ENV" = "production" ]; then
              echo "::error::  - KUBECONFIG_PRODUCTION (required for production)"
            else
              echo "::error::  - KUBECONFIG_STAGING (required for staging)"
            fi
            echo "::error::"
            echo "::error::To set secrets:"
            echo "::error::  1. Go to Repository Settings > Secrets and variables > Actions"
            echo "::error::  2. Click 'New repository secret'"
            echo "::error::  3. Add the required secret name and value"
            echo "::error::  4. Re-run this workflow"
            exit 1
          fi
          
          echo "‚úÖ Kubeconfig secret validated successfully for environment: $ENV"
          echo "   Secret length: ${#KUBECONFIG_SECRET} characters"

      - name: üîê Configure kubectl
        env:
          KUBECONFIG_SECRET: ${{ env.KUBECONFIG_SECRET }}
        uses: azure/k8s-set-context@v3
        with:
          method: kubeconfig
          kubeconfig: ${{ env.KUBECONFIG_SECRET }}

      - name: ‚è™ Rollback deployment
        run: |
          echo "‚è™ Rolling back deployment..."
          kubectl rollout undo deployment/dese-api-deployment -n default
          kubectl rollout status deployment/dese-api-deployment -n default --timeout=5m

      - name: ‚úÖ Verify rollback
        run: |
          kubectl get deployment dese-api-deployment -n default
          PODS=$(kubectl get pods -n default -l app=dese-api)
          if [[ -n "$PODS" ]]; then
            echo "‚úÖ Rollback successful"
          else
            echo "‚ùå Rollback failed"
            exit 1
          fi

      - name: üìß Notify team
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
        run: |
          if [ -n "${SLACK_WEBHOOK}" ]; then
            curl -X POST -H 'Content-type: application/json' \
              --data '{"text":"üîÑ Deployment failed, automatic rollback initiated"}' \
              "${SLACK_WEBHOOK}" || echo "Slack notification skipped"
          else
            echo "Slack webhook not configured, skipping notification"
          fi

